package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.48

import (
	"context"
	"fmt"

	"github.com/mikalai2006/swapland-api/graph/generated"
	"github.com/mikalai2006/swapland-api/graph/model"
	"github.com/mikalai2006/swapland-api/internal/domain"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo/options"
)

// ReviewsConnection is the resolver for the reviewsConnection field.
func (r *queryResolver) ReviewsConnection(ctx context.Context, first *int, after *string, limit *int, skip *int, input *model.FetchReview) (*model.ReviewsConnection, error) {
	var results *model.ReviewsConnection

	// The cursor is base64 encoded by convention, so we need to decode it first
	var decodedCursor string
	if after != nil {
		// b, err := primitive.ObjectIDFromHex(*after)
		// if err != nil {
		// 	return nil, err
		// }
		decodedCursor = *after //string(b)
	}

	count := 0
	currentPage := false

	if decodedCursor == "" {
		currentPage = true
	}
	hasNextPage := false

	options := options.Find()
	options.SetSort(bson.D{{"createdAt", -1}})
	if limit != nil {
		options.SetLimit(int64(*first))
	}
	options.SetSkip(int64(*skip))

	filter := bson.D{}
	if input.UserID != nil {
		userIDPrimitive, err := primitive.ObjectIDFromHex(*input.UserID)
		if err != nil {
			return results, err
		}

		filter = append(filter, bson.E{"user_id", userIDPrimitive})
	}
	if input.NodeID != nil {
		nodeDPrimitive, err := primitive.ObjectIDFromHex(*input.NodeID)
		if err != nil {
			return results, err
		}

		filter = append(filter, bson.E{"node_id", nodeDPrimitive})
	}

	// allItems, err := r.Repo.Review.GqlGetReviews(domain.RequestParams{
	// 	Options: domain.Options{Limit: int64(*limit), Sort: bson.D{bson.E{"created_at", -1}}},
	// 	Filter:  filter,
	// })

	if after != nil && *after != "" {
		idPrimitive, err := primitive.ObjectIDFromHex(*after)
		if err != nil {
			return results, err
		}

		filter = append(filter, bson.E{"_id", bson.D{{"$lt", idPrimitive}}})
		// filter = append(filter, bson.E{"createdAt", bson.D{{"$lt", &after}}})
	}

	// var allItems []model.Review
	// cursor, err := r.DB.Collection(repository.TblReview).Find(ctx, filter, options)
	// if err != nil {
	// 	return results, err
	// }
	// defer cursor.Close(ctx)

	// if er := cursor.All(ctx, &allItems); er != nil {
	// 	return results, er
	// }
	// fmt.Println(filter, options, len(allItems))

	var allItems []*model.Review
	allItems, err := r.Repo.Review.GqlGetReviews(domain.RequestParams{
		Options: domain.Options{
			//Limit: (*options.Limit + 1),
			// Skip:  *options.Skip,
			Sort: bson.D{{"_id", -1}},
		},
		Filter: filter,
	})
	if err != nil {
		return results, err
	}

	if len(allItems) == 0 {
		return results, nil
	}

	// if err != nil {
	// 	return results, err
	// }
	// if len(allItems) == 0 {
	// 	return results, err
	// }

	// edges := make([]*model.ReviewEdge, len(allItems))
	// for i, _ := range allItems {

	// 	edges[i] = &model.ReviewEdge{
	// 		Cursor: allItems[i].ID.Hex(),
	// 		Node:   allItems[i],
	// 	}
	// }

	// fetch only the required
	// part of data from the database
	var edges []*model.ReviewEdge
	for i, _ := range allItems {
		if allItems[i].CreatedAt.String() == decodedCursor {
			currentPage = true
		}

		if currentPage {
		}

		if count < *first {
			edges = append(edges, &model.ReviewEdge{
				Cursor: allItems[i].ID.Hex(),
				Node:   allItems[i],
			})
			count++
		}

		// If there are any elements left after the current page
		// we indicate that in the response
		if count == *first && i < len(allItems)-1 {
			hasNextPage = true
		}
	}

	// fmt.Println("NodesConnection decodedCursor=", decodedCursor, *first, count, len(allItems), len(edges))

	pageInfo := model.PageInfo{
		StartCursor: edges[0].Node.ID.Hex(),
		EndCursor:   edges[len(edges)-1].Node.ID.Hex(),
		// StartCursor: edges[0].Node.CreatedAt.String(),
		// EndCursor:   edges[count-1].Node.CreatedAt.String(),
		HasNextPage: &hasNextPage,
	}

	totalResults := model.ReviewsConnection{
		Edges:    edges,
		PageInfo: &pageInfo,
	}

	return &totalResults, nil
}

// Review is the resolver for the review field.
func (r *queryResolver) Review(ctx context.Context, input *model.FetchReview) (*model.Review, error) {
	var result *model.Review

	filter := bson.D{}
	if input.ID != nil {
		iDPrimitive, err := primitive.ObjectIDFromHex(*input.ID)
		if err != nil {
			return result, err
		}

		filter = append(filter, bson.E{"_id", iDPrimitive})
	}
	if input.NodeID != nil {
		filter = append(filter, bson.E{"node_id", input.NodeID})
	}
	if input.UserID != nil {
		userIDPrimitive, err := primitive.ObjectIDFromHex(*input.UserID)
		if err != nil {
			return result, err
		}
		filter = append(filter, bson.E{"user_id", userIDPrimitive})
	}
	fmt.Println(filter)

	allItems, err := r.Repo.Review.GqlGetReviews(domain.RequestParams{
		Options: domain.Options{Limit: 1},
		Filter:  filter,
	})
	if err != nil {
		return result, err
	}
	if len(allItems) == 0 {
		return result, err
	}
	return allItems[0], err
	// if err := r.DB.Collection(repository.TblReview).FindOne(ctx, filter).Decode(&result); err != nil {
	// 	if errors.Is(err, mongo.ErrNoDocuments) {
	// 		return result, model.ErrReviewNotFound
	// 	}
	// 	return result, err
	// }
	// return result, nil
}

// ID is the resolver for the _id field.
func (r *reviewResolver) ID(ctx context.Context, obj *model.Review) (string, error) {
	return obj.ID.Hex(), nil
}

// UserID is the resolver for the userId field.
func (r *reviewResolver) UserID(ctx context.Context, obj *model.Review) (string, error) {
	return obj.UserID.Hex(), nil
}

// NodeID is the resolver for the nodeId field.
func (r *reviewResolver) NodeID(ctx context.Context, obj *model.Review) (string, error) {
	return obj.NodeID.Hex(), nil
}

// Review returns generated.ReviewResolver implementation.
func (r *Resolver) Review() generated.ReviewResolver { return &reviewResolver{r} }

type reviewResolver struct{ *Resolver }
