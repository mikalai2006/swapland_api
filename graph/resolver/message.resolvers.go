package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.48

import (
	"context"
	"fmt"

	"github.com/mikalai2006/swapland-api/graph/generated"
	"github.com/mikalai2006/swapland-api/graph/model"
	"github.com/mikalai2006/swapland-api/internal/repository"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

// ID is the resolver for the id field.
func (r *messageResolver) ID(ctx context.Context, obj *model.Message) (string, error) {
	return obj.ID.Hex(), nil
}

// UserID is the resolver for the userId field.
func (r *messageResolver) UserID(ctx context.Context, obj *model.Message) (string, error) {
	return obj.UserID.Hex(), nil
}

// Props is the resolver for the props field.
func (r *messageResolver) Props(ctx context.Context, obj *model.Message) (any, error) {
	return obj.Props, nil
}

// Messages is the resolver for the messages field.
func (r *queryResolver) Messages(ctx context.Context, limit *int, skip *int, input *model.ParamsMessage) (*model.PaginationMessage, error) {
	null := 0
	results := &model.PaginationMessage{
		Total: &null,
		Data:  []*model.Message{},
		Limit: limit,
		Skip:  skip,
	}
	q := bson.D{}

	if input.UserID != nil {
		userIds := make([]primitive.ObjectID, 1)
		userIDPrimitive, err := primitive.ObjectIDFromHex(*input.UserID)
		if err != nil {
			return nil, err
		}
		userIds = append(userIds, userIDPrimitive)
		q = append(q, bson.E{"user_id", bson.D{{"$in", userIds}}})
	}

	pipe := mongo.Pipeline{}
	pipe = append(pipe, bson.D{{"$match", q}})

	pipe = append(pipe, bson.D{{Key: "$lookup", Value: bson.M{
		"from": "users",
		"as":   "userb",
		"let":  bson.D{{Key: "userId", Value: "$user_id"}},
		"pipeline": mongo.Pipeline{
			bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$_id", "$$userId"}}}}},
			bson.D{{"$limit", 1}},
			bson.D{{
				Key: "$lookup",
				Value: bson.M{
					"from": "image",
					"as":   "images",
					"let":  bson.D{{Key: "serviceId", Value: bson.D{{"$toString", "$_id"}}}},
					"pipeline": mongo.Pipeline{
						bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$service_id", "$$serviceId"}}}}},
					},
				},
			}},
		},
	}}})
	pipe = append(pipe, bson.D{{Key: "$set", Value: bson.M{"user": bson.M{"$first": "$userb"}}}})

	if skip != nil {
		pipe = append(pipe, bson.D{{"$skip", skip}})
	}
	if limit != nil {
		pipe = append(pipe, bson.D{{"$limit", limit}})
	}
	// pipe = append(pipe, bson.D{{"$sort", bson.D{{"lat", 1}}}})
	var allItems []model.Message
	cursor, err := r.DB.Collection(repository.TblMessage).Aggregate(ctx, pipe) //Aggregate(ctx, pipe) // Find(ctx, q, options)
	if err != nil {
		return results, err
	}
	defer cursor.Close(ctx)
	if er := cursor.All(ctx, &allItems); er != nil {
		return results, er
	}

	// fmt.Println("allItems len=", len(allItems))

	if len(allItems) == 0 {
		return results, nil
	}

	data := make([]*model.Message, len(allItems))
	for i, _ := range allItems {

		data[i] = &allItems[i]
	}
	// fmt.Println("Find total: ", len(data))
	total := len(data)
	results = &model.PaginationMessage{
		Total: &total,
		Data:  data,
		Limit: limit,
		Skip:  skip,
	}

	return results, nil
}

// Message is the resolver for the message field.
func (r *queryResolver) Message(ctx context.Context, id *string) (*model.Message, error) {
	panic(fmt.Errorf("not implemented: Message - message"))
}

// Message returns generated.MessageResolver implementation.
func (r *Resolver) Message() generated.MessageResolver { return &messageResolver{r} }

type messageResolver struct{ *Resolver }
