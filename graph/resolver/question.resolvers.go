package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.48

import (
	"context"
	"fmt"

	"github.com/mikalai2006/swapland-api/graph/generated"
	"github.com/mikalai2006/swapland-api/graph/model"
	"github.com/mikalai2006/swapland-api/internal/repository"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

// Questions is the resolver for the questions field.
func (r *queryResolver) Questions(ctx context.Context, first *int, after *string, limit *int, skip *int, input *model.FetchQuestion) (*model.PaginationQuestion, error) {
	null := 0
	results := &model.PaginationQuestion{
		Total: &null,
		Data:  []*model.Question{},
		Limit: limit,
		Skip:  skip,
	}
	q := bson.D{}

	if input.ProductID != nil {
		productIds := make([]primitive.ObjectID, 1)
		productIDPrimitive, err := primitive.ObjectIDFromHex(*input.ProductID)
		if err != nil {
			return nil, err
		}
		productIds = append(productIds, productIDPrimitive)
		q = append(q, bson.E{"product_id", bson.D{{"$in", productIds}}})
	}

	if input.UserID != nil {
		userIds := make([]primitive.ObjectID, 1)
		userIDPrimitive, err := primitive.ObjectIDFromHex(*input.UserID)
		if err != nil {
			return nil, err
		}
		userIds = append(userIds, userIDPrimitive)
		q = append(q, bson.E{"user_id", bson.D{{"$in", userIds}}})
	}

	pipe := mongo.Pipeline{}
	pipe = append(pipe, bson.D{{"$match", q}})

	pipe = append(pipe, bson.D{{Key: "$lookup", Value: bson.M{
		"from": "users",
		"as":   "userb",
		"let":  bson.D{{Key: "userId", Value: "$user_id"}},
		"pipeline": mongo.Pipeline{
			bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$_id", "$$userId"}}}}},
			bson.D{{"$limit", 1}},
			bson.D{{
				Key: "$lookup",
				Value: bson.M{
					"from": "image",
					"as":   "images",
					"let":  bson.D{{Key: "serviceId", Value: bson.D{{"$toString", "$_id"}}}},
					"pipeline": mongo.Pipeline{
						bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$service_id", "$$serviceId"}}}}},
					},
				},
			}},
		},
	}}})
	pipe = append(pipe, bson.D{{Key: "$set", Value: bson.M{"user": bson.M{"$first": "$userb"}}}})

	if skip != nil {
		pipe = append(pipe, bson.D{{"$skip", skip}})
	}
	if limit != nil {
		pipe = append(pipe, bson.D{{"$limit", limit}})
	}
	// pipe = append(pipe, bson.D{{"$sort", bson.D{{"lat", 1}}}})
	var allItems []model.Question
	cursor, err := r.DB.Collection(repository.TblQuestion).Aggregate(ctx, pipe) //Aggregate(ctx, pipe) // Find(ctx, q, options)
	if err != nil {
		return results, err
	}
	defer cursor.Close(ctx)
	if er := cursor.All(ctx, &allItems); er != nil {
		return results, er
	}

	// fmt.Println("allItems len=", len(allItems))

	if len(allItems) == 0 {
		return results, nil
	}

	data := make([]*model.Question, len(allItems))
	for i, _ := range allItems {

		data[i] = &allItems[i]
	}
	// fmt.Println("Find total: ", len(data))
	total := len(data)
	results = &model.PaginationQuestion{
		Total: &total,
		Data:  data,
		Limit: limit,
		Skip:  skip,
	}

	return results, nil
}

// Question is the resolver for the question field.
func (r *queryResolver) Question(ctx context.Context, input *model.FetchQuestion) (*model.Question, error) {
	panic(fmt.Errorf("not implemented: Question - question"))
}

// ID is the resolver for the id field.
func (r *questionResolver) ID(ctx context.Context, obj *model.Question) (string, error) {
	return obj.ID.Hex(), nil
}

// UserID is the resolver for the userId field.
func (r *questionResolver) UserID(ctx context.Context, obj *model.Question) (string, error) {
	return obj.UserID.Hex(), nil
}

// ProductID is the resolver for the productId field.
func (r *questionResolver) ProductID(ctx context.Context, obj *model.Question) (string, error) {
	return obj.ProductID.Hex(), nil
}

// Question returns generated.QuestionResolver implementation.
func (r *Resolver) Question() generated.QuestionResolver { return &questionResolver{r} }

type questionResolver struct{ *Resolver }
