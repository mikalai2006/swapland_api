package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.48

import (
	"context"
	"fmt"

	"github.com/mikalai2006/swapland-api/graph/generated"
	"github.com/mikalai2006/swapland-api/graph/model"
	"github.com/mikalai2006/swapland-api/internal/repository"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

// Subscribes is the resolver for the subscribes field.
func (r *queryResolver) Subscribes(ctx context.Context, first *int, after *string, limit *int, skip *int, input *model.FetchSubscribe) (*model.PaginationSubscribe, error) {
	null := 0
	results := &model.PaginationSubscribe{
		Total: &null,
		Data:  []*model.Subscribe{},
		Limit: limit,
		Skip:  skip,
	}
	q := bson.D{}

	if input.SubUserID != nil {
		ids := make([]primitive.ObjectID, 1)
		subUserIDPrimitive, err := primitive.ObjectIDFromHex(*input.SubUserID)
		if err != nil {
			return nil, err
		}
		ids = append(ids, subUserIDPrimitive)
		q = append(q, bson.E{"sub_user_id", bson.D{{"$in", ids}}})
	}

	if input.UserID != nil {
		userIds := make([]primitive.ObjectID, 1)
		userIDPrimitive, err := primitive.ObjectIDFromHex(*input.UserID)
		if err != nil {
			return nil, err
		}
		userIds = append(userIds, userIDPrimitive)
		q = append(q, bson.E{"user_id", bson.D{{"$in", userIds}}})
	}

	pipe := mongo.Pipeline{}
	pipe = append(pipe, bson.D{{"$match", q}})

	pipe = append(pipe, bson.D{{Key: "$lookup", Value: bson.M{
		"from": "users",
		"as":   "userb",
		"let":  bson.D{{Key: "userId", Value: "$user_id"}},
		"pipeline": mongo.Pipeline{
			bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$_id", "$$userId"}}}}},
			bson.D{{"$limit", 1}},
			bson.D{{
				Key: "$lookup",
				Value: bson.M{
					"from": "image",
					"as":   "images",
					"let":  bson.D{{Key: "serviceId", Value: bson.D{{"$toString", "$_id"}}}},
					"pipeline": mongo.Pipeline{
						bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$service_id", "$$serviceId"}}}}},
					},
				},
			}},
		},
	}}})
	pipe = append(pipe, bson.D{{Key: "$set", Value: bson.M{"user": bson.M{"$first": "$userb"}}}})

	pipe = append(pipe, bson.D{{Key: "$lookup", Value: bson.M{
		"from": "users",
		"as":   "userx",
		"let":  bson.D{{Key: "subUserId", Value: "$sub_user_id"}},
		"pipeline": mongo.Pipeline{
			bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$_id", "$$subUserId"}}}}},
			bson.D{{"$limit", 1}},
			bson.D{{
				Key: "$lookup",
				Value: bson.M{
					"from": "image",
					"as":   "images",
					"let":  bson.D{{Key: "serviceId", Value: bson.D{{"$toString", "$_id"}}}},
					"pipeline": mongo.Pipeline{
						bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$service_id", "$$serviceId"}}}}},
					},
				},
			}},
		},
	}}})
	pipe = append(pipe, bson.D{{Key: "$set", Value: bson.M{"sub_user": bson.M{"$first": "$userx"}}}})

	if skip != nil {
		pipe = append(pipe, bson.D{{"$skip", skip}})
	}
	if limit != nil {
		pipe = append(pipe, bson.D{{"$limit", limit}})
	}
	// pipe = append(pipe, bson.D{{"$sort", bson.D{{"lat", 1}}}})
	var allItems []model.Subscribe
	cursor, err := r.DB.Collection(repository.TblSubscribe).Aggregate(ctx, pipe) //Aggregate(ctx, pipe) // Find(ctx, q, options)
	if err != nil {
		return results, err
	}
	defer cursor.Close(ctx)
	if er := cursor.All(ctx, &allItems); er != nil {
		return results, er
	}

	// fmt.Println("allItems len=", len(allItems))

	if len(allItems) == 0 {
		return results, nil
	}

	data := make([]*model.Subscribe, len(allItems))
	for i, _ := range allItems {

		data[i] = &allItems[i]
	}
	// fmt.Println("Find total: ", len(data))
	total := len(data)
	results = &model.PaginationSubscribe{
		Total: &total,
		Data:  data,
		Limit: limit,
		Skip:  skip,
	}

	return results, nil
}

// Subscribe is the resolver for the subscribe field.
func (r *queryResolver) Subscribe(ctx context.Context, input *model.FetchSubscribe) (*model.Subscribe, error) {
	panic(fmt.Errorf("not implemented: Subscribe - subscribe"))
}

// ID is the resolver for the id field.
func (r *subscribeResolver) ID(ctx context.Context, obj *model.Subscribe) (string, error) {
	return obj.ID.Hex(), nil
}

// UserID is the resolver for the userId field.
func (r *subscribeResolver) UserID(ctx context.Context, obj *model.Subscribe) (string, error) {
	return obj.UserID.Hex(), nil
}

// SubUserID is the resolver for the subUserId field.
func (r *subscribeResolver) SubUserID(ctx context.Context, obj *model.Subscribe) (string, error) {
	return obj.SubUserID.Hex(), nil
}

// Subscribe returns generated.SubscribeResolver implementation.
func (r *Resolver) Subscribe() generated.SubscribeResolver { return &subscribeResolver{r} }

type subscribeResolver struct{ *Resolver }
