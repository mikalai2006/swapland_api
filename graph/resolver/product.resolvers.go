package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.48

import (
	"context"
	"fmt"

	"github.com/mikalai2006/swapland-api/graph/generated"
	"github.com/mikalai2006/swapland-api/graph/model"
	"github.com/mikalai2006/swapland-api/internal/repository"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

// ID is the resolver for the id field.
func (r *productResolver) ID(ctx context.Context, obj *model.Product) (string, error) {
	return obj.ID.Hex(), nil
}

// UserID is the resolver for the userId field.
func (r *productResolver) UserID(ctx context.Context, obj *model.Product) (string, error) {
	return obj.UserID.Hex(), nil
}

// CategoryID is the resolver for the categoryId field.
func (r *productResolver) CategoryID(ctx context.Context, obj *model.Product) (string, error) {
	return obj.CategoryID.Hex(), nil
}

// Props is the resolver for the props field.
func (r *productResolver) Props(ctx context.Context, obj *model.Product) (any, error) {
	return obj.Props, nil
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context, limit *int, skip *int, input *model.ParamsProduct) (*model.PaginationProduct, error) {
	var results *model.PaginationProduct
	// gc, err := utils.GinContextFromContext(ctx)
	// if err != nil {
	// 	return nil, err
	// }
	// md, err := middleware.GetMaxDistance(gc)
	// if err != nil {
	// 	return nil, err
	// }
	// fmt.Println("max distance=", md)

	// options := options.Find()
	// //options.SetSort(bson.D{{"createdAt", 1}})
	// if limit != nil {
	// 	options.SetLimit(int64(*limit))
	// }
	// options.SetSkip(int64(*skip))
	q := bson.D{}

	// if input.LatA != nil {
	// 	q = append(q, bson.E{"lat", bson.D{{"$gt", input.LatA}}})
	// }
	// if input.LatB != nil {
	// 	q = append(q, bson.E{"lat", bson.D{{"$lt", input.LatB}}})
	// }
	// if input.LonA != nil {
	// 	q = append(q, bson.E{"lon", bson.D{{"$gt", input.LonA}}})
	// }
	// if input.LonB != nil {
	// 	q = append(q, bson.E{"lon", bson.D{{"$lt", input.LonB}}})
	// }

	// if input.Center != nil && len(input.Center) == 2 {

	// 	lat := *input.Center[0]
	// 	lon := *input.Center[1]
	// 	latAccuracy := float64(float64(180*md*1000) / 40075017)
	// 	lngAccuracy := float64(latAccuracy) / math.Cos(float64(math.Pi/180)*lat)

	// 	latA := lat - float64(latAccuracy)
	// 	if input.LatA != nil && latA < *input.LatA {
	// 		latA = *input.LatA
	// 	}
	// 	lonA := lon - lngAccuracy
	// 	if input.LonA != nil && lonA < *input.LonA {
	// 		lonA = *input.LonA
	// 	}
	// 	latB := lat + float64(latAccuracy)
	// 	if input.LatB != nil && latB > *input.LatB {
	// 		latB = *input.LatB
	// 	}
	// 	lonB := lon + lngAccuracy
	// 	if input.LonB != nil && lonB > *input.LonB {
	// 		lonB = *input.LonB
	// 	}
	// 	// fmt.Println("center: ", lat, lon)
	// 	// fmt.Println("latAccuracy: ", latAccuracy)
	// 	// fmt.Println("lngAccuracy: ", lngAccuracy)
	// 	// fmt.Println("bounds: ", latA, lonA, ":", latB, lonB)
	// 	q = append(q, bson.E{"lat", bson.D{{"$gt", latA}}})
	// 	q = append(q, bson.E{"lon", bson.D{{"$gt", lonA}}})
	// 	q = append(q, bson.E{"lat", bson.D{{"$lt", latB}}})
	// 	q = append(q, bson.E{"lon", bson.D{{"$lt", lonB}}})
	// }

	// if input.Type != nil && len(input.Type) > 0 {
	// 	types := make([]string, len(input.Type))
	// 	for i := range input.Type {
	// 		types[i] = *input.Type[i]
	// 	}
	// 	q = append(q, bson.E{"type", bson.D{{"$in", types}}})
	// }

	// Filter by substring name
	if input.Query != nil && *input.Query != "" {
		strName := primitive.Regex{Pattern: fmt.Sprintf("%v", *input.Query), Options: "i"}
		q = append(q, bson.E{"title", bson.D{{"$regex", strName}}})
		// fmt.Println("q:", q)
	}
	if input.UserID != nil && *input.UserID != "" {
		userIDPrimitive, err := primitive.ObjectIDFromHex(*input.UserID)
		if err != nil {
			return nil, err
		}
		q = append(q, bson.E{"user_id", userIDPrimitive})
	}

	// Filter by category
	if input.CategoryID != nil && len(input.CategoryID) > 0 {
		categories := make([]primitive.ObjectID, len(input.CategoryID))
		for i := range input.CategoryID {
			categoryIDPrimitive, err := primitive.ObjectIDFromHex(*input.CategoryID[i])
			if err != nil {
				return nil, err
			}
			categories[i] = categoryIDPrimitive
		}
		// fmt.Println(len(input.CategoryID), categories)
		q = append(q, bson.E{"category_id", bson.D{{"$in", categories}}})
	}

	// inputData := []model.NodeFilterTag{}
	// err := json.Unmarshal([]byte(*input.Filter), &inputData)
	// if err != nil {
	// 	return results, err
	// }

	pipe := mongo.Pipeline{}
	pipe = append(pipe, bson.D{{"$match", q}})

	if input.Sort != nil && len(input.Sort) > 0 {
		sortParam := bson.D{}
		for i := range input.Sort {
			sortParam = append(sortParam, bson.E{*input.Sort[i].Key, *input.Sort[i].Value})
		}
		pipe = append(pipe, bson.D{{"$sort", sortParam}})
		// fmt.Println("sortParam: ", len(input.Sort), sortParam, pipe)
	}

	pipe = append(pipe, bson.D{{Key: "$lookup", Value: bson.M{
		"from": "nodedata",
		// "let":  bson.D{{Key: "nodeId", Value: bson.D{{"$toString", "$_id"}}}},
		// "pipeline": mongo.Pipeline{
		// 	bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$node_id", "$$nodeId"}}}}},
		// },
		"localField":   "_id",
		"foreignField": "node_id",
		"as":           "data",
	}}})
	pipe = append(pipe,
		bson.D{{
			Key: "$lookup",
			Value: bson.M{
				"from": "image",
				"as":   "images",
				"let":  bson.D{{Key: "serviceId", Value: bson.D{{"$toString", "$_id"}}}},
				"pipeline": mongo.Pipeline{
					bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$service_id", "$$serviceId"}}}}},
				},
			},
		}})

	pipe = append(pipe, bson.D{{Key: "$lookup", Value: bson.M{
		"as":   "offers",
		"from": "offer",
		"let":  bson.D{{Key: "productId", Value: "$_id"}},
		"pipeline": mongo.Pipeline{
			bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$product_id", "$$productId"}}}}},
			bson.D{{Key: "$lookup", Value: bson.M{
				"from": "users",
				"as":   "usera",
				"let":  bson.D{{Key: "userId", Value: "$user_id"}},
				"pipeline": mongo.Pipeline{
					bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$_id", "$$userId"}}}}},
					bson.D{{"$limit", 1}},
					bson.D{{
						Key: "$lookup",
						Value: bson.M{
							"as":   "images",
							"from": "image",
							"let":  bson.D{{Key: "serviceId", Value: bson.D{{"$toString", "$_id"}}}},
							"pipeline": mongo.Pipeline{
								bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$service_id", "$$serviceId"}}}}},
							},
						},
					}},
				},
			}}},
			bson.D{{Key: "$set", Value: bson.M{"user": bson.M{"$first": "$usera"}}}},

			// tagopt
			bson.D{{Key: "$lookup", Value: bson.M{
				"from": "tagopt",
				"as":   "tagopts",
				"let":  bson.D{{Key: "tagoptId", Value: "$tagopt_id"}},
				"pipeline": mongo.Pipeline{
					bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$_id", "$$tagoptId"}}}}},
					bson.D{{"$limit", 1}},
					// bson.D{{
					// 	Key: "$lookup",
					// 	Value: bson.M{
					// 		"as":   "images",
					// 		"from": "image",
					// 		"let":  bson.D{{Key: "serviceId", Value: bson.D{{"$toString", "$_id"}}}},
					// 		"pipeline": mongo.Pipeline{
					// 			bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$service_id", "$$serviceId"}}}}},
					// 		},
					// 	},
					// }},
				},
			}}},
			bson.D{{Key: "$set", Value: bson.M{"tagopt": bson.M{"$first": "$tagopts"}}}},

			// tag
			bson.D{{Key: "$lookup", Value: bson.M{
				"from": repository.TblTag,
				"as":   "tags",
				"let":  bson.D{{Key: "tagId", Value: "$tag_id"}},
				"pipeline": mongo.Pipeline{
					bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$_id", "$$tagId"}}}}},
					bson.D{{"$limit", 1}},
					// bson.D{{
					// 	Key: "$lookup",
					// 	Value: bson.M{
					// 		"as":   "images",
					// 		"from": "image",
					// 		"let":  bson.D{{Key: "serviceId", Value: bson.D{{"$toString", "$_id"}}}},
					// 		"pipeline": mongo.Pipeline{
					// 			bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$service_id", "$$serviceId"}}}}},
					// 		},
					// 	},
					// }},
				},
			}}},
			bson.D{{Key: "$set", Value: bson.M{"tag": bson.M{"$first": "$tags"}}}},

			// audit section
			bson.D{{Key: "$lookup", Value: bson.M{
				"as":   "audit",
				"from": "nodedata_audit",
				"let":  bson.D{{Key: "nodedataId", Value: "$_id"}},
				"pipeline": mongo.Pipeline{
					bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$nodedata_id", "$$nodedataId"}}}}},
					bson.D{{Key: "$lookup", Value: bson.M{
						"from": "users",
						"as":   "userc",
						"let":  bson.D{{Key: "userId", Value: "$user_id"}},
						"pipeline": mongo.Pipeline{
							bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$_id", "$$userId"}}}}},
							bson.D{{"$limit", 1}},
							bson.D{{
								Key: "$lookup",
								Value: bson.M{
									"as":   "images",
									"from": "image",
									"let":  bson.D{{Key: "serviceId", Value: bson.D{{"$toString", "$_id"}}}},
									"pipeline": mongo.Pipeline{
										bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$service_id", "$$serviceId"}}}}},
									},
								},
							}},
						},
					}}},
					bson.D{{Key: "$set", Value: bson.M{"user": bson.M{"$first": "$userc"}}}},
				},
				// "localField":   "_id",
				// "foreignField": "node_id",
			}}},
		},
		// "localField":   "_id",
		// "foreignField": "node_id",
	}}})

	pipe = append(pipe, bson.D{{Key: "$lookup", Value: bson.M{
		"from": "users",
		"as":   "userb",
		"let":  bson.D{{Key: "userId", Value: "$user_id"}},
		"pipeline": mongo.Pipeline{
			bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$_id", "$$userId"}}}}},
			bson.D{{"$limit", 1}},
			bson.D{{
				Key: "$lookup",
				Value: bson.M{
					"from": "image",
					"as":   "images",
					"let":  bson.D{{Key: "serviceId", Value: bson.D{{"$toString", "$_id"}}}},
					"pipeline": mongo.Pipeline{
						bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$service_id", "$$serviceId"}}}}},
					},
				},
			}},
		},
	}}})
	pipe = append(pipe, bson.D{{Key: "$set", Value: bson.M{"user": bson.M{"$first": "$userb"}}}})

	type ItemFilter struct {
		Type      string
		CountCond int
	}

	// inputData := input.Filter
	// if len(inputData) > 0 {
	// 	// -> 1
	// 	itemFilter := []ItemFilter{}
	// 	filterOutput := bson.M{}
	// 	filter := []bson.M{}
	// 	for i := range inputData {
	// 		newItemFilter := ItemFilter{
	// 			Type:      input.Filter[i].Type,
	// 			CountCond: len(inputData[i].Options),
	// 		}
	// 		// typeFilter := ""
	// 		filterTypeOptions := bson.A{}
	// 		if input.Filter[i].Type != "" {
	// 			// typeFilter = input.Filter[i].Type
	// 			filterTypeOptions = append(filterTypeOptions, bson.M{"$eq": bson.A{"$type", input.Filter[i].Type}})
	// 		} else {
	// 			continue
	// 		}

	// 		if len(inputData[i].Options) > 0 {
	// 			filterOptions := bson.A{}
	// 			for j := range inputData[i].Options {
	// 				tID, _ := primitive.ObjectIDFromHex(inputData[i].Options[j].TagID)

	// 				arrValue := bson.A{}
	// 				for v := range inputData[i].Options[j].Value {
	// 					arrValue = append(arrValue, inputData[i].Options[j].Value[v])
	// 				}

	// 				filterOptions = append(filterOptions, bson.M{
	// 					"$and": bson.A{
	// 						bson.M{
	// 							"$eq": bson.A{"$$item.tag_id", tID},
	// 						},
	// 						bson.M{
	// 							"$in": bson.A{"$$item.data.value", arrValue},
	// 						},
	// 					},
	// 					// "data.tag_id": tID,
	// 					// "data.data.value": bson.D{
	// 					// 	{"$in", arrValue},
	// 					// },
	// 				})
	// 			}
	// 			filterTypeOptions = append(filterTypeOptions, bson.M{"$or": filterOptions})
	// 			// filterTypeOptions["$and"] = filterOptions
	// 		}

	// 		filter = append(filter, bson.M{"$and": filterTypeOptions})
	// 		itemFilter = append(itemFilter, newItemFilter)
	// 	}
	// 	filterOutput["$or"] = filter
	// 	// filterOutput = append(filterOutput, bson.E{"$or", filter})

	// 	pipeBranches := bson.A{}
	// 	for i := range itemFilter {
	// 		pipeBranches = append(pipeBranches, bson.M{
	// 			"case": bson.M{
	// 				"$eq": bson.A{"$type", itemFilter[i].Type},
	// 			},
	// 			"then": itemFilter[i].CountCond,
	// 		})
	// 	}
	// 	// fmt.Println(pipeBranches)
	// 	pipe = append(pipe, bson.D{
	// 		{"$addFields", bson.M{
	// 			"countCond": bson.M{
	// 				"$switch": bson.M{
	// 					"branches": pipeBranches,
	// 					"default":  -1,
	// 				},
	// 			},
	// 		}},
	// 	})

	// 	pipe = append(pipe, bson.D{
	// 		{"$addFields", bson.M{
	// 			"dataCount": bson.M{
	// 				"$size": bson.M{
	// 					"$filter": bson.M{
	// 						"input": "$data",
	// 						"as":    "item",
	// 						"cond":  filterOutput,
	// 					},
	// 				},
	// 			},
	// 		}},
	// 	})
	// 	// pipe = append(pipe, bson.D{
	// 	// 	{"$addFields", bson.M{
	// 	// 		"data": bson.M{
	// 	// 			"count": "$dataCount",
	// 	// 		},
	// 	// 	}},
	// 	// })
	// 	pipe = append(pipe, bson.D{
	// 		{"$match", bson.M{
	// 			// "dataCount": bson.M{
	// 			// 	"$gt": 0,
	// 			// },
	// 			"$expr": bson.M{
	// 				"$and": bson.A{
	// 					bson.M{"$gte": bson.A{"$dataCount", "$countCond"}},
	// 					bson.M{"$ne": bson.A{"$countCond", -1}},
	// 				},
	// 			},
	// 		}}})
	// 	// fmt.Println("pipe=", pipe)

	// 	//////////////////// 2
	// 	// filterNodeData := mongo.Pipeline{}
	// 	// // filterNodeData = append(filterNodeData, bson.D{{Key: "$lookup", Value: bson.M{
	// 	// // 	"from": "node",
	// 	// // 	// "let":  bson.D{{Key: "nodeId", Value: bson.D{{"$toString", "$_id"}}}},
	// 	// // 	// "pipeline": mongo.Pipeline{
	// 	// // 	// 	bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$node_id", "$$nodeId"}}}}},
	// 	// // 	// },
	// 	// // 	"localField":   "node_id",
	// 	// // 	"foreignField": "_id",
	// 	// // 	"as":           "node",
	// 	// // }}})
	// 	// // filterNodeData = append(filterNodeData, bson.D{{"$unwind", bson.D{{"path", "$node"}}}})

	// 	// filter := []bson.M{}
	// 	// for i := range inputData {
	// 	// 	// typeFilter := ""
	// 	// 	filterTypeOptions := bson.A{}
	// 	// 	if input.Filter[i].Type != "" {
	// 	// 		filterTypeOptions = append(filterTypeOptions, bson.M{"type": input.Filter[i].Type})
	// 	// 	} else {
	// 	// 		continue
	// 	// 	}

	// 	// 	// if input.LatA != nil {
	// 	// 	// 	filterTypeOptions = append(filterTypeOptions, bson.M{"lat": bson.D{{"$gt", *input.LatA}}})
	// 	// 	// }
	// 	// 	// if input.LatB != nil {
	// 	// 	// 	filterTypeOptions = append(filterTypeOptions, bson.M{"lat": bson.D{{"$lt", *input.LatB}}})
	// 	// 	// }
	// 	// 	// if input.LonA != nil {
	// 	// 	// 	filterTypeOptions = append(filterTypeOptions, bson.M{"lon": bson.D{{"$gt", *input.LonA}}})
	// 	// 	// }
	// 	// 	// if input.LonB != nil {
	// 	// 	// 	filterTypeOptions = append(filterTypeOptions, bson.M{"lon": bson.D{{"$lt", *input.LonB}}})
	// 	// 	// }

	// 	// 	if len(inputData[i].Options) > 0 {
	// 	// 		filterOptions := bson.A{}
	// 	// 		for j := range inputData[i].Options {
	// 	// 			tID, _ := primitive.ObjectIDFromHex(inputData[i].Options[j].TagID)

	// 	// 			arrValue := bson.A{}
	// 	// 			for v := range inputData[i].Options[j].Value {
	// 	// 				arrValue = append(arrValue, inputData[i].Options[j].Value[v])
	// 	// 			}

	// 	// 			filterOptions = append(filterOptions, bson.M{
	// 	// 				"tag_id": tID,
	// 	// 				"data.value": bson.D{
	// 	// 					{"$in", arrValue},
	// 	// 				},
	// 	// 			})
	// 	// 		}
	// 	// 		filterTypeOptions = append(filterTypeOptions, bson.M{"$and": filterOptions})
	// 	// 		// filterTypeOptions["$and"] = filterOptions
	// 	// 	}

	// 	// 	filter = append(filter, bson.M{"$and": filterTypeOptions})
	// 	// }
	// 	// filterNodeData = append(filterNodeData, bson.D{{"$match", bson.D{{"$or", filter}}}})

	// 	// fmt.Println("filterOutput=", filterNodeData)

	// 	// var allAllowOpts []model.Nodedata
	// 	// // if limit != nil {
	// 	// // 	filterOutput = append(filterOutput, bson.M{"$limit": limit})
	// 	// // }
	// 	// cur, err := r.DB.Collection(repository.TblNodedata).Aggregate(ctx, filterNodeData)
	// 	// if err != nil {
	// 	// 	return results, err
	// 	// }
	// 	// if er := cur.All(ctx, &allAllowOpts); er != nil {
	// 	// 	return results, er
	// 	// }
	// 	// fmt.Println("len=", len(allAllowOpts))
	// 	// IDs := []primitive.ObjectID{}
	// 	// for e := range allAllowOpts {
	// 	// 	IDs = append(IDs, allAllowOpts[e].NodeID)
	// 	// }
	// 	// fmt.Println("IDs len=", len(IDs))
	// 	// fmt.Println("filterOutput <<<<<=================")

	// 	// pipe = append(pipe, bson.D{{"$match", bson.D{{"_id", bson.D{{"$in", IDs}}}}}})
	// 	// // fmt.Println("pipe=", pipe)
	// }

	// if input.Name != nil && *input.Name != "" {
	// 	var allAllowOpts []model.Nodedata
	// 	fmt.Println("Filter by name=================>>>>>")
	// 	aggregateQuery := []bson.M{}
	// 	strName := primitive.Regex{Pattern: fmt.Sprintf("^%v", *input.Name), Options: "i"}
	// 	fmt.Println("strName: ", strName)
	// 	tID, _ := primitive.ObjectIDFromHex("650712e1d1f4b9ad0b718092")
	// 	aggregateQuery = append(aggregateQuery, bson.M{"$match": bson.D{
	// 		{"$and", bson.A{
	// 			bson.D{{"tag_id", tID}},
	// 			bson.D{{"data.value", bson.D{{"$regex", strName}}}},
	// 		}},
	// 	}})
	// 	fmt.Println("aggregateQuery=", aggregateQuery)
	// 	// aggregateQuery = append(aggregateQuery,
	// 	// 	bson.M{"$lookup": bson.M{
	// 	// 		"from":         "tag",
	// 	// 		"as":           "tagg",
	// 	// 		"foreignField": "tag_id",
	// 	// 		"localField":   "_id",
	// 	// 	},
	// 	// 	})
	// 	if limit != nil {
	// 		aggregateQuery = append(aggregateQuery, bson.M{"$limit": limit})
	// 	}
	// 	cur, err := r.DB.Collection(repository.TblNodedata).Aggregate(ctx, aggregateQuery)
	// 	if err != nil {
	// 		return results, err
	// 	}
	// 	if er := cur.All(ctx, &allAllowOpts); er != nil {
	// 		return results, er
	// 	}
	// 	fmt.Println("len=", len(allAllowOpts))
	// 	IDs := []primitive.ObjectID{}
	// 	for e := range allAllowOpts {
	// 		IDs = append(IDs, allAllowOpts[e].NodeID)
	// 	}
	// 	fmt.Println("IDs len=", len(IDs))
	// 	fmt.Println("Filter by name<<<<<=================")
	// 	q = append(q, bson.E{"_id", bson.D{{"$in", IDs}}})
	// 	// fmt.Println("q=", q)
	// }

	if skip != nil {
		pipe = append(pipe, bson.D{{"$skip", skip}})
	}
	if limit != nil {
		pipe = append(pipe, bson.D{{"$limit", limit}})
	}
	// pipe = append(pipe, bson.D{{"$sort", bson.D{{"lat", 1}}}})
	var allItems []model.Product
	cursor, err := r.DB.Collection(repository.TblProduct).Aggregate(ctx, pipe) //Aggregate(ctx, pipe) // Find(ctx, q, options)
	if err != nil {
		return results, err
	}
	defer cursor.Close(ctx)
	if er := cursor.All(ctx, &allItems); er != nil {
		return results, er
	}

	// fmt.Println("allItems len=", len(allItems))

	if len(allItems) == 0 {
		return results, nil
	}

	data := make([]*model.Product, len(allItems))
	for i, _ := range allItems {

		data[i] = &allItems[i]
	}
	// fmt.Println("Find total: ", len(data))
	total := len(data)
	results = &model.PaginationProduct{
		Total: &total,
		Data:  data,
		Limit: limit,
		Skip:  skip,
	}

	return results, nil
}

// Product is the resolver for the product field.
func (r *queryResolver) Product(ctx context.Context, id *string) (*model.Product, error) {
	var result *model.Product

	filter := bson.D{}
	if id != nil {
		userIDPrimitive, err := primitive.ObjectIDFromHex(*id)
		if err != nil {
			return result, err
		}

		filter = append(filter, bson.E{"_id", userIDPrimitive})
	}

	pipe := mongo.Pipeline{}
	pipe = append(pipe, bson.D{{"$match", filter}})
	pipe = append(pipe, bson.D{{"$limit", 1}})

	pipe = append(pipe, bson.D{{Key: "$lookup", Value: bson.M{
		"from": "users",
		"as":   "userb",
		"let":  bson.D{{Key: "userId", Value: "$user_id"}},
		"pipeline": mongo.Pipeline{
			bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$_id", "$$userId"}}}}},
			bson.D{{"$limit", 1}},
			bson.D{{
				Key: "$lookup",
				Value: bson.M{
					"from": "image",
					"as":   "images",
					"let":  bson.D{{Key: "serviceId", Value: bson.D{{"$toString", "$_id"}}}},
					"pipeline": mongo.Pipeline{
						bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$service_id", "$$serviceId"}}}}},
					},
				},
			}},
		},
	}}})
	pipe = append(pipe, bson.D{{Key: "$set", Value: bson.M{"user": bson.M{"$first": "$userb"}}}})
	pipe = append(pipe, bson.D{{Key: "$lookup", Value: bson.M{
		"as":   "offers",
		"from": "offer",
		"let":  bson.D{{Key: "productId", Value: "$_id"}},
		"pipeline": mongo.Pipeline{
			bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$product_id", "$$productId"}}}}},
			bson.D{{Key: "$lookup", Value: bson.M{
				"from": "users",
				"as":   "usera",
				"let":  bson.D{{Key: "userId", Value: "$user_id"}},
				"pipeline": mongo.Pipeline{
					bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$_id", "$$userId"}}}}},
					bson.D{{"$limit", 1}},
					bson.D{{
						Key: "$lookup",
						Value: bson.M{
							"as":   "images",
							"from": "image",
							"let":  bson.D{{Key: "serviceId", Value: bson.D{{"$toString", "$_id"}}}},
							"pipeline": mongo.Pipeline{
								bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$service_id", "$$serviceId"}}}}},
							},
						},
					}},
				},
			}}},
			bson.D{{Key: "$set", Value: bson.M{"user": bson.M{"$first": "$usera"}}}},

			// tagopt
			bson.D{{Key: "$lookup", Value: bson.M{
				"from": "tagopt",
				"as":   "tagopts",
				"let":  bson.D{{Key: "tagoptId", Value: "$tagopt_id"}},
				"pipeline": mongo.Pipeline{
					bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$_id", "$$tagoptId"}}}}},
					bson.D{{"$limit", 1}},
					// bson.D{{
					// 	Key: "$lookup",
					// 	Value: bson.M{
					// 		"as":   "images",
					// 		"from": "image",
					// 		"let":  bson.D{{Key: "serviceId", Value: bson.D{{"$toString", "$_id"}}}},
					// 		"pipeline": mongo.Pipeline{
					// 			bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$service_id", "$$serviceId"}}}}},
					// 		},
					// 	},
					// }},
				},
			}}},
			bson.D{{Key: "$set", Value: bson.M{"tagopt": bson.M{"$first": "$tagopts"}}}},

			// tag
			bson.D{{Key: "$lookup", Value: bson.M{
				"from": repository.TblTag,
				"as":   "tags",
				"let":  bson.D{{Key: "tagId", Value: "$tag_id"}},
				"pipeline": mongo.Pipeline{
					bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$_id", "$$tagId"}}}}},
					bson.D{{"$limit", 1}},
					// bson.D{{
					// 	Key: "$lookup",
					// 	Value: bson.M{
					// 		"as":   "images",
					// 		"from": "image",
					// 		"let":  bson.D{{Key: "serviceId", Value: bson.D{{"$toString", "$_id"}}}},
					// 		"pipeline": mongo.Pipeline{
					// 			bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$service_id", "$$serviceId"}}}}},
					// 		},
					// 	},
					// }},
				},
			}}},
			bson.D{{Key: "$set", Value: bson.M{"tag": bson.M{"$first": "$tags"}}}},

			// audit section
			bson.D{{Key: "$lookup", Value: bson.M{
				"as":   "audit",
				"from": "nodedata_audit",
				"let":  bson.D{{Key: "nodedataId", Value: "$_id"}},
				"pipeline": mongo.Pipeline{
					bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$nodedata_id", "$$nodedataId"}}}}},
					bson.D{{Key: "$lookup", Value: bson.M{
						"from": "users",
						"as":   "userc",
						"let":  bson.D{{Key: "userId", Value: "$user_id"}},
						"pipeline": mongo.Pipeline{
							bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$_id", "$$userId"}}}}},
							bson.D{{"$limit", 1}},
							bson.D{{
								Key: "$lookup",
								Value: bson.M{
									"as":   "images",
									"from": "image",
									"let":  bson.D{{Key: "serviceId", Value: bson.D{{"$toString", "$_id"}}}},
									"pipeline": mongo.Pipeline{
										bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$service_id", "$$serviceId"}}}}},
									},
								},
							}},
						},
					}}},
					bson.D{{Key: "$set", Value: bson.M{"user": bson.M{"$first": "$userc"}}}},
				},
				// "localField":   "_id",
				// "foreignField": "node_id",
			}}},
		},
		// "localField":   "_id",
		// "foreignField": "node_id",
	}}})

	pipe = append(pipe, bson.D{{Key: "$lookup", Value: bson.M{
		"as":   "images",
		"from": "image",
		"let":  bson.D{{Key: "serviceId", Value: bson.D{{"$toString", "$_id"}}}},
		"pipeline": mongo.Pipeline{
			bson.D{{Key: "$match", Value: bson.M{"$and": bson.A{
				bson.M{"$expr": bson.M{"$eq": [2]string{"$service_id", "$$serviceId"}}},
				bson.M{"$expr": bson.M{"$eq": [2]string{"$service", "product"}}},
			}},
			}},
			bson.D{{Key: "$lookup", Value: bson.M{
				"from": "users",
				"as":   "usera",
				"let":  bson.D{{Key: "userId", Value: "$user_id"}},
				"pipeline": mongo.Pipeline{
					bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$_id", "$$userId"}}}}},
					bson.D{{"$limit", 1}},
					bson.D{{
						Key: "$lookup",
						Value: bson.M{
							"as":   "images",
							"from": "image",
							"let":  bson.D{{Key: "serviceId", Value: bson.D{{"$toString", "$_id"}}}},
							"pipeline": mongo.Pipeline{
								bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$service_id", "$$serviceId"}}}}},
							},
						},
					}},
				},
			}}},
			bson.D{{Key: "$set", Value: bson.M{"user": bson.M{"$first": "$usera"}}}},
		},

		// "localField":   "_id",
		// "foreignField": "node_id",
	}}})

	// if err := r.DB.Collection(repository.TblNode).FindOne(ctx, filter).Decode(&result); err != nil {
	// 	if errors.Is(err, mongo.ErrNoDocuments) {
	// 		return result, model.ErrNodeNotFound
	// 	}
	// 	return result, err
	// }
	var allItems []model.Product
	cursor, err := r.DB.Collection(repository.TblProduct).Aggregate(ctx, pipe) //Aggregate(ctx, pipe) // Find(ctx, q, options)
	if err != nil {
		return result, err
	}
	defer cursor.Close(ctx)
	if er := cursor.All(ctx, &allItems); er != nil {
		return result, er
	}

	if len(allItems) > 0 {
		result = &allItems[0]
	}

	return result, nil
}

// Product returns generated.ProductResolver implementation.
func (r *Resolver) Product() generated.ProductResolver { return &productResolver{r} }

type productResolver struct{ *Resolver }
