package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.48

import (
	"context"

	"github.com/mikalai2006/swapland-api/graph/generated"
	"github.com/mikalai2006/swapland-api/graph/model"
	"github.com/mikalai2006/swapland-api/internal/domain"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

// ID is the resolver for the id field.
func (r *nodeVoteResolver) ID(ctx context.Context, obj *model.NodeVote) (string, error) {
	return obj.ID.Hex(), nil
}

// UserID is the resolver for the userId field.
func (r *nodeVoteResolver) UserID(ctx context.Context, obj *model.NodeVote) (string, error) {
	return obj.UserID.Hex(), nil
}

// NodeID is the resolver for the nodeId field.
func (r *nodeVoteResolver) NodeID(ctx context.Context, obj *model.NodeVote) (string, error) {
	return obj.NodeID.Hex(), nil
}

// NodeUserID is the resolver for the nodeUserId field.
func (r *nodeVoteResolver) NodeUserID(ctx context.Context, obj *model.NodeVote) (string, error) {
	return obj.NodeUserID.Hex(), nil
}

// Value is the resolver for the value field.
func (r *nodeVoteResolver) Value(ctx context.Context, obj *model.NodeVote) (any, error) {
	return obj.Value, nil
}

// Nodevotes is the resolver for the nodevotes field.
func (r *queryResolver) Nodevotes(ctx context.Context, limit *int, skip *int, input *model.FetchNodeVote) (*model.PaginationNodeVote, error) {
	var results *model.PaginationNodeVote

	filter := bson.D{}
	if input.NodeID != nil {
		nID, _ := primitive.ObjectIDFromHex(*input.NodeID)
		filter = append(filter, bson.E{"node_id", nID})
	}
	if input.UserID != nil {
		tID, _ := primitive.ObjectIDFromHex(*input.UserID)
		filter = append(filter, bson.E{"user_id", tID})
	}
	if input.NodeUserID != nil {
		nuID, _ := primitive.ObjectIDFromHex(*input.NodeUserID)
		filter = append(filter, bson.E{"node_user_id", nuID})
	}

	allItems, err := r.Repo.NodeVote.FindNodeVote(domain.RequestParams{
		Options: domain.Options{Limit: int64(*limit), Sort: bson.D{{"updated_at", -1}}},
		Filter:  filter,
	})
	if err != nil {
		return results, err
	}

	data := make([]*model.NodeVote, len(allItems.Data))
	for i, _ := range allItems.Data {
		data[i] = &allItems.Data[i]
	}

	total := len(data)

	results = &model.PaginationNodeVote{
		Data:  data,
		Total: &total,
		Limit: limit,
		Skip:  skip,
	}

	return results, nil
}

// NodeVote returns generated.NodeVoteResolver implementation.
func (r *Resolver) NodeVote() generated.NodeVoteResolver { return &nodeVoteResolver{r} }

type nodeVoteResolver struct{ *Resolver }
